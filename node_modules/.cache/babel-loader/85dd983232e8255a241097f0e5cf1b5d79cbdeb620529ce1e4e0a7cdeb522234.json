{"ast":null,"code":"export class FileTransferService {\n  // 从1000减小到200字节\n\n  // 解析文件头信息\n  static parseHeader(data) {\n    try {\n      const header = JSON.parse(data);\n      if (!header.name || !header.total_chunks) {\n        throw new Error('Invalid header format');\n      }\n      return header;\n    } catch (e) {\n      throw new Error('Invalid header data');\n    }\n  }\n\n  // 将文件分割成二维码数据块\n  static async fileToQRChunks(file) {\n    const chunks = [];\n    const fileBuffer = await file.arrayBuffer();\n    const uint8Array = new Uint8Array(fileBuffer);\n\n    // 计算文件哈希\n    const fileHash = await this.calculateFileHash(uint8Array);\n\n    // 文件头信息\n    const header = {\n      name: file.name,\n      total_chunks: Math.ceil(file.size / this.CHUNK_SIZE),\n      hash: fileHash\n    };\n    chunks.push(JSON.stringify(header));\n\n    // 分块处理\n    for (let i = 0; i < uint8Array.length; i += this.CHUNK_SIZE) {\n      const chunk = uint8Array.slice(i, i + this.CHUNK_SIZE);\n      const chunkData = {\n        index: Math.floor(i / this.CHUNK_SIZE),\n        data: this.arrayBufferToBase64(chunk),\n        total_chunks: Math.ceil(uint8Array.length / this.CHUNK_SIZE),\n        name: file.name\n      };\n      chunks.push(JSON.stringify(chunkData));\n    }\n    return chunks;\n  }\n\n  // 从二维码数据块重建文件\n  static async qrChunksToFile(chunks, fileName) {\n    if (chunks.length === 0) {\n      throw new Error('No chunks provided');\n    }\n\n    // 解析文件头\n    const headerChunk = chunks.find(chunk => {\n      const parsed = JSON.parse(chunk);\n      return parsed.total_chunks && parsed.name;\n    });\n    if (!headerChunk) {\n      throw new Error('No valid file header found');\n    }\n    const header = JSON.parse(headerChunk);\n    const expectedChunks = header.total_chunks;\n    const expectedHash = header.hash;\n    const finalFileName = fileName || header.name;\n\n    // 解析数据块\n    const dataChunks = chunks.filter(chunk => {\n      const parsed = JSON.parse(chunk);\n      return parsed.index !== undefined && parsed.data;\n    }).sort((a, b) => {\n      const chunkA = JSON.parse(a);\n      const chunkB = JSON.parse(b);\n      return chunkA.index - chunkB.index;\n    });\n    if (dataChunks.length !== expectedChunks) {\n      throw new Error(`Incomplete chunks received. Expected ${expectedChunks}, got ${dataChunks.length}`);\n    }\n\n    // 重组文件数据\n    const fileChunks = dataChunks.map(chunk => {\n      const chunkData = JSON.parse(chunk);\n      return this.base64ToArrayBuffer(chunkData.data);\n    });\n\n    // 合并文件数据\n    const combinedBuffer = this.concatenateArrayBuffers(fileChunks);\n    const uint8Array = new Uint8Array(combinedBuffer);\n\n    // 验证文件完整性\n    if (expectedHash) {\n      const actualHash = await this.calculateFileHash(uint8Array);\n      if (actualHash !== expectedHash) {\n        throw new Error('File integrity check failed');\n      }\n    }\n\n    // 创建文件\n    return new File([uint8Array], finalFileName, {\n      type: 'application/octet-stream'\n    });\n  }\n\n  // 计算文件哈希值（使用 Web Crypto API）\n  static async calculateFileHash(data) {\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');\n  }\n\n  // ArrayBuffer 转 Base64\n  static arrayBufferToBase64(buffer) {\n    return btoa(String.fromCharCode.apply(null, Array.from(buffer)));\n  }\n\n  // Base64 转 ArrayBuffer\n  static base64ToArrayBuffer(base64) {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n  }\n\n  // 合并多个 ArrayBuffer\n  static concatenateArrayBuffers(buffers) {\n    const totalLength = buffers.reduce((acc, buffer) => acc + buffer.byteLength, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const buffer of buffers) {\n      result.set(new Uint8Array(buffer), offset);\n      offset += buffer.byteLength;\n    }\n    return result.buffer;\n  }\n}\n// 减小分块大小，适应二维码限制\nFileTransferService.CHUNK_SIZE = 200;","map":{"version":3,"names":["FileTransferService","parseHeader","data","header","JSON","parse","name","total_chunks","Error","e","fileToQRChunks","file","chunks","fileBuffer","arrayBuffer","uint8Array","Uint8Array","fileHash","calculateFileHash","Math","ceil","size","CHUNK_SIZE","hash","push","stringify","i","length","chunk","slice","chunkData","index","floor","arrayBufferToBase64","qrChunksToFile","fileName","headerChunk","find","parsed","expectedChunks","expectedHash","finalFileName","dataChunks","filter","undefined","sort","a","b","chunkA","chunkB","fileChunks","map","base64ToArrayBuffer","combinedBuffer","concatenateArrayBuffers","actualHash","File","type","hashBuffer","crypto","subtle","digest","Array","from","toString","padStart","join","buffer","btoa","String","fromCharCode","apply","base64","binaryString","atob","bytes","charCodeAt","buffers","totalLength","reduce","acc","byteLength","result","offset","set"],"sources":["/Users/zhangrongwu/workspace/AI-Project/file-transfer-web/src/services/fileTransferService.ts"],"sourcesContent":["import { createHash } from 'crypto';\n\ninterface FileHeader {\n  name: string;\n  total_chunks: number;  // 与 Flutter 版本保持一致\n  hash?: string;\n}\n\ninterface ChunkData {\n  index: number;\n  data: string;\n  total_chunks: number;  // 与 Flutter 版本保持一致\n  name?: string;\n}\n\nexport class FileTransferService {\n  // 减小分块大小，适应二维码限制\n  private static readonly CHUNK_SIZE = 200; // 从1000减小到200字节\n\n  // 解析文件头信息\n  static parseHeader(data: string): FileHeader {\n    try {\n      const header = JSON.parse(data) as FileHeader;\n      if (!header.name || !header.total_chunks) {\n        throw new Error('Invalid header format');\n      }\n      return header;\n    } catch (e) {\n      throw new Error('Invalid header data');\n    }\n  }\n\n  // 将文件分割成二维码数据块\n  static async fileToQRChunks(file: File): Promise<string[]> {\n    const chunks: string[] = [];\n    const fileBuffer = await file.arrayBuffer();\n    const uint8Array = new Uint8Array(fileBuffer);\n\n    // 计算文件哈希\n    const fileHash = await this.calculateFileHash(uint8Array);\n\n    // 文件头信息\n    const header: FileHeader = {\n      name: file.name,\n      total_chunks: Math.ceil(file.size / this.CHUNK_SIZE),\n      hash: fileHash,\n    };\n    chunks.push(JSON.stringify(header));\n\n    // 分块处理\n    for (let i = 0; i < uint8Array.length; i += this.CHUNK_SIZE) {\n      const chunk = uint8Array.slice(i, i + this.CHUNK_SIZE);\n      const chunkData: ChunkData = {\n        index: Math.floor(i / this.CHUNK_SIZE),\n        data: this.arrayBufferToBase64(chunk),\n        total_chunks: Math.ceil(uint8Array.length / this.CHUNK_SIZE),\n        name: file.name,\n      };\n      chunks.push(JSON.stringify(chunkData));\n    }\n\n    return chunks;\n  }\n\n  // 从二维码数据块重建文件\n  static async qrChunksToFile(chunks: string[], fileName?: string): Promise<File> {\n    if (chunks.length === 0) {\n      throw new Error('No chunks provided');\n    }\n\n    // 解析文件头\n    const headerChunk = chunks.find(chunk => {\n      const parsed = JSON.parse(chunk);\n      return parsed.total_chunks && parsed.name;\n    });\n\n    if (!headerChunk) {\n      throw new Error('No valid file header found');\n    }\n\n    const header = JSON.parse(headerChunk) as FileHeader;\n    const expectedChunks = header.total_chunks;\n    const expectedHash = header.hash;\n    const finalFileName = fileName || header.name;\n\n    // 解析数据块\n    const dataChunks = chunks.filter(chunk => {\n      const parsed = JSON.parse(chunk);\n      return parsed.index !== undefined && parsed.data;\n    }).sort((a, b) => {\n      const chunkA = JSON.parse(a) as ChunkData;\n      const chunkB = JSON.parse(b) as ChunkData;\n      return chunkA.index - chunkB.index;\n    });\n\n    if (dataChunks.length !== expectedChunks) {\n      throw new Error(`Incomplete chunks received. Expected ${expectedChunks}, got ${dataChunks.length}`);\n    }\n\n    // 重组文件数据\n    const fileChunks = dataChunks.map(chunk => {\n      const chunkData = JSON.parse(chunk) as ChunkData;\n      return this.base64ToArrayBuffer(chunkData.data);\n    });\n\n    // 合并文件数据\n    const combinedBuffer = this.concatenateArrayBuffers(fileChunks);\n    const uint8Array = new Uint8Array(combinedBuffer);\n\n    // 验证文件完整性\n    if (expectedHash) {\n      const actualHash = await this.calculateFileHash(uint8Array);\n      if (actualHash !== expectedHash) {\n        throw new Error('File integrity check failed');\n      }\n    }\n\n    // 创建文件\n    return new File([uint8Array], finalFileName, { type: 'application/octet-stream' });\n  }\n\n  // 计算文件哈希值（使用 Web Crypto API）\n  private static async calculateFileHash(data: Uint8Array): Promise<string> {\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    return Array.from(new Uint8Array(hashBuffer))\n      .map(b => b.toString(16).padStart(2, '0'))\n      .join('');\n  }\n\n  // ArrayBuffer 转 Base64\n  private static arrayBufferToBase64(buffer: Uint8Array): string {\n    return btoa(String.fromCharCode.apply(null, Array.from(buffer)));\n  }\n\n  // Base64 转 ArrayBuffer\n  private static base64ToArrayBuffer(base64: string): ArrayBuffer {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n  }\n\n  // 合并多个 ArrayBuffer\n  private static concatenateArrayBuffers(buffers: ArrayBuffer[]): ArrayBuffer {\n    const totalLength = buffers.reduce((acc, buffer) => acc + buffer.byteLength, 0);\n    const result = new Uint8Array(totalLength);\n    \n    let offset = 0;\n    for (const buffer of buffers) {\n      result.set(new Uint8Array(buffer), offset);\n      offset += buffer.byteLength;\n    }\n    \n    return result.buffer;\n  }\n}\n"],"mappings":"AAeA,OAAO,MAAMA,mBAAmB,CAAC;EAEW;;EAE1C;EACA,OAAOC,WAAWA,CAACC,IAAY,EAAc;IAC3C,IAAI;MACF,MAAMC,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACH,IAAI,CAAe;MAC7C,IAAI,CAACC,MAAM,CAACG,IAAI,IAAI,CAACH,MAAM,CAACI,YAAY,EAAE;QACxC,MAAM,IAAIC,KAAK,CAAC,uBAAuB,CAAC;MAC1C;MACA,OAAOL,MAAM;IACf,CAAC,CAAC,OAAOM,CAAC,EAAE;MACV,MAAM,IAAID,KAAK,CAAC,qBAAqB,CAAC;IACxC;EACF;;EAEA;EACA,aAAaE,cAAcA,CAACC,IAAU,EAAqB;IACzD,MAAMC,MAAgB,GAAG,EAAE;IAC3B,MAAMC,UAAU,GAAG,MAAMF,IAAI,CAACG,WAAW,CAAC,CAAC;IAC3C,MAAMC,UAAU,GAAG,IAAIC,UAAU,CAACH,UAAU,CAAC;;IAE7C;IACA,MAAMI,QAAQ,GAAG,MAAM,IAAI,CAACC,iBAAiB,CAACH,UAAU,CAAC;;IAEzD;IACA,MAAMZ,MAAkB,GAAG;MACzBG,IAAI,EAAEK,IAAI,CAACL,IAAI;MACfC,YAAY,EAAEY,IAAI,CAACC,IAAI,CAACT,IAAI,CAACU,IAAI,GAAG,IAAI,CAACC,UAAU,CAAC;MACpDC,IAAI,EAAEN;IACR,CAAC;IACDL,MAAM,CAACY,IAAI,CAACpB,IAAI,CAACqB,SAAS,CAACtB,MAAM,CAAC,CAAC;;IAEnC;IACA,KAAK,IAAIuB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,UAAU,CAACY,MAAM,EAAED,CAAC,IAAI,IAAI,CAACJ,UAAU,EAAE;MAC3D,MAAMM,KAAK,GAAGb,UAAU,CAACc,KAAK,CAACH,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACJ,UAAU,CAAC;MACtD,MAAMQ,SAAoB,GAAG;QAC3BC,KAAK,EAAEZ,IAAI,CAACa,KAAK,CAACN,CAAC,GAAG,IAAI,CAACJ,UAAU,CAAC;QACtCpB,IAAI,EAAE,IAAI,CAAC+B,mBAAmB,CAACL,KAAK,CAAC;QACrCrB,YAAY,EAAEY,IAAI,CAACC,IAAI,CAACL,UAAU,CAACY,MAAM,GAAG,IAAI,CAACL,UAAU,CAAC;QAC5DhB,IAAI,EAAEK,IAAI,CAACL;MACb,CAAC;MACDM,MAAM,CAACY,IAAI,CAACpB,IAAI,CAACqB,SAAS,CAACK,SAAS,CAAC,CAAC;IACxC;IAEA,OAAOlB,MAAM;EACf;;EAEA;EACA,aAAasB,cAAcA,CAACtB,MAAgB,EAAEuB,QAAiB,EAAiB;IAC9E,IAAIvB,MAAM,CAACe,MAAM,KAAK,CAAC,EAAE;MACvB,MAAM,IAAInB,KAAK,CAAC,oBAAoB,CAAC;IACvC;;IAEA;IACA,MAAM4B,WAAW,GAAGxB,MAAM,CAACyB,IAAI,CAACT,KAAK,IAAI;MACvC,MAAMU,MAAM,GAAGlC,IAAI,CAACC,KAAK,CAACuB,KAAK,CAAC;MAChC,OAAOU,MAAM,CAAC/B,YAAY,IAAI+B,MAAM,CAAChC,IAAI;IAC3C,CAAC,CAAC;IAEF,IAAI,CAAC8B,WAAW,EAAE;MAChB,MAAM,IAAI5B,KAAK,CAAC,4BAA4B,CAAC;IAC/C;IAEA,MAAML,MAAM,GAAGC,IAAI,CAACC,KAAK,CAAC+B,WAAW,CAAe;IACpD,MAAMG,cAAc,GAAGpC,MAAM,CAACI,YAAY;IAC1C,MAAMiC,YAAY,GAAGrC,MAAM,CAACoB,IAAI;IAChC,MAAMkB,aAAa,GAAGN,QAAQ,IAAIhC,MAAM,CAACG,IAAI;;IAE7C;IACA,MAAMoC,UAAU,GAAG9B,MAAM,CAAC+B,MAAM,CAACf,KAAK,IAAI;MACxC,MAAMU,MAAM,GAAGlC,IAAI,CAACC,KAAK,CAACuB,KAAK,CAAC;MAChC,OAAOU,MAAM,CAACP,KAAK,KAAKa,SAAS,IAAIN,MAAM,CAACpC,IAAI;IAClD,CAAC,CAAC,CAAC2C,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;MAChB,MAAMC,MAAM,GAAG5C,IAAI,CAACC,KAAK,CAACyC,CAAC,CAAc;MACzC,MAAMG,MAAM,GAAG7C,IAAI,CAACC,KAAK,CAAC0C,CAAC,CAAc;MACzC,OAAOC,MAAM,CAACjB,KAAK,GAAGkB,MAAM,CAAClB,KAAK;IACpC,CAAC,CAAC;IAEF,IAAIW,UAAU,CAACf,MAAM,KAAKY,cAAc,EAAE;MACxC,MAAM,IAAI/B,KAAK,CAAC,wCAAwC+B,cAAc,SAASG,UAAU,CAACf,MAAM,EAAE,CAAC;IACrG;;IAEA;IACA,MAAMuB,UAAU,GAAGR,UAAU,CAACS,GAAG,CAACvB,KAAK,IAAI;MACzC,MAAME,SAAS,GAAG1B,IAAI,CAACC,KAAK,CAACuB,KAAK,CAAc;MAChD,OAAO,IAAI,CAACwB,mBAAmB,CAACtB,SAAS,CAAC5B,IAAI,CAAC;IACjD,CAAC,CAAC;;IAEF;IACA,MAAMmD,cAAc,GAAG,IAAI,CAACC,uBAAuB,CAACJ,UAAU,CAAC;IAC/D,MAAMnC,UAAU,GAAG,IAAIC,UAAU,CAACqC,cAAc,CAAC;;IAEjD;IACA,IAAIb,YAAY,EAAE;MAChB,MAAMe,UAAU,GAAG,MAAM,IAAI,CAACrC,iBAAiB,CAACH,UAAU,CAAC;MAC3D,IAAIwC,UAAU,KAAKf,YAAY,EAAE;QAC/B,MAAM,IAAIhC,KAAK,CAAC,6BAA6B,CAAC;MAChD;IACF;;IAEA;IACA,OAAO,IAAIgD,IAAI,CAAC,CAACzC,UAAU,CAAC,EAAE0B,aAAa,EAAE;MAAEgB,IAAI,EAAE;IAA2B,CAAC,CAAC;EACpF;;EAEA;EACA,aAAqBvC,iBAAiBA,CAAChB,IAAgB,EAAmB;IACxE,MAAMwD,UAAU,GAAG,MAAMC,MAAM,CAACC,MAAM,CAACC,MAAM,CAAC,SAAS,EAAE3D,IAAI,CAAC;IAC9D,OAAO4D,KAAK,CAACC,IAAI,CAAC,IAAI/C,UAAU,CAAC0C,UAAU,CAAC,CAAC,CAC1CP,GAAG,CAACJ,CAAC,IAAIA,CAAC,CAACiB,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CACzCC,IAAI,CAAC,EAAE,CAAC;EACb;;EAEA;EACA,OAAejC,mBAAmBA,CAACkC,MAAkB,EAAU;IAC7D,OAAOC,IAAI,CAACC,MAAM,CAACC,YAAY,CAACC,KAAK,CAAC,IAAI,EAAET,KAAK,CAACC,IAAI,CAACI,MAAM,CAAC,CAAC,CAAC;EAClE;;EAEA;EACA,OAAef,mBAAmBA,CAACoB,MAAc,EAAe;IAC9D,MAAMC,YAAY,GAAGC,IAAI,CAACF,MAAM,CAAC;IACjC,MAAMG,KAAK,GAAG,IAAI3D,UAAU,CAACyD,YAAY,CAAC9C,MAAM,CAAC;IACjD,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+C,YAAY,CAAC9C,MAAM,EAAED,CAAC,EAAE,EAAE;MAC5CiD,KAAK,CAACjD,CAAC,CAAC,GAAG+C,YAAY,CAACG,UAAU,CAAClD,CAAC,CAAC;IACvC;IACA,OAAOiD,KAAK,CAACR,MAAM;EACrB;;EAEA;EACA,OAAeb,uBAAuBA,CAACuB,OAAsB,EAAe;IAC1E,MAAMC,WAAW,GAAGD,OAAO,CAACE,MAAM,CAAC,CAACC,GAAG,EAAEb,MAAM,KAAKa,GAAG,GAAGb,MAAM,CAACc,UAAU,EAAE,CAAC,CAAC;IAC/E,MAAMC,MAAM,GAAG,IAAIlE,UAAU,CAAC8D,WAAW,CAAC;IAE1C,IAAIK,MAAM,GAAG,CAAC;IACd,KAAK,MAAMhB,MAAM,IAAIU,OAAO,EAAE;MAC5BK,MAAM,CAACE,GAAG,CAAC,IAAIpE,UAAU,CAACmD,MAAM,CAAC,EAAEgB,MAAM,CAAC;MAC1CA,MAAM,IAAIhB,MAAM,CAACc,UAAU;IAC7B;IAEA,OAAOC,MAAM,CAACf,MAAM;EACtB;AACF;AA7IE;AADWnE,mBAAmB,CAENsB,UAAU,GAAG,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}