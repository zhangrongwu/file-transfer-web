{"ast":null,"code":"export class FileTransferService{// 从1000减小到200字节\n// 解析文件头信息\nstatic parseHeader(data){try{const header=JSON.parse(data);if(!header.name||!header.total_chunks){throw new Error('Invalid header format');}return header;}catch(e){throw new Error('Invalid header data');}}// 将文件分割成二维码数据块\nstatic async fileToQRChunks(file){const chunks=[];const fileBuffer=await file.arrayBuffer();const uint8Array=new Uint8Array(fileBuffer);// 计算文件哈希\nconst fileHash=await this.calculateFileHash(uint8Array);// 文件头信息\nconst header={name:file.name,total_chunks:Math.ceil(file.size/this.CHUNK_SIZE),hash:fileHash};chunks.push(JSON.stringify(header));// 分块处理\nfor(let i=0;i<uint8Array.length;i+=this.CHUNK_SIZE){const chunk=uint8Array.slice(i,i+this.CHUNK_SIZE);const chunkData={index:Math.floor(i/this.CHUNK_SIZE),data:this.arrayBufferToBase64(chunk),total_chunks:Math.ceil(uint8Array.length/this.CHUNK_SIZE),name:file.name};chunks.push(JSON.stringify(chunkData));}return chunks;}// 从二维码数据块重建文件\nstatic async qrChunksToFile(chunks,fileName){if(chunks.length===0){throw new Error('No chunks provided');}// 解析文件头\nconst headerChunk=chunks.find(chunk=>{const parsed=JSON.parse(chunk);return parsed.total_chunks&&parsed.name;});if(!headerChunk){throw new Error('No valid file header found');}const header=JSON.parse(headerChunk);const expectedChunks=header.total_chunks;const expectedHash=header.hash;const finalFileName=fileName||header.name;// 解析数据块\nconst dataChunks=chunks.filter(chunk=>{const parsed=JSON.parse(chunk);return parsed.index!==undefined&&parsed.data;}).sort((a,b)=>{const chunkA=JSON.parse(a);const chunkB=JSON.parse(b);return chunkA.index-chunkB.index;});if(dataChunks.length!==expectedChunks){throw new Error(\"Incomplete chunks received. Expected \".concat(expectedChunks,\", got \").concat(dataChunks.length));}// 重组文件数据\nconst fileChunks=dataChunks.map(chunk=>{const chunkData=JSON.parse(chunk);return this.base64ToArrayBuffer(chunkData.data);});// 合并文件数据\nconst combinedBuffer=this.concatenateArrayBuffers(fileChunks);const uint8Array=new Uint8Array(combinedBuffer);// 验证文件完整性\nif(expectedHash){const actualHash=await this.calculateFileHash(uint8Array);if(actualHash!==expectedHash){throw new Error('File integrity check failed');}}// 创建文件\nreturn new File([uint8Array],finalFileName,{type:'application/octet-stream'});}// 计算文件哈希值（使用 Web Crypto API）\nstatic async calculateFileHash(data){const hashBuffer=await crypto.subtle.digest('SHA-256',data);return Array.from(new Uint8Array(hashBuffer)).map(b=>b.toString(16).padStart(2,'0')).join('');}// ArrayBuffer 转 Base64\nstatic arrayBufferToBase64(buffer){return btoa(String.fromCharCode.apply(null,Array.from(buffer)));}// Base64 转 ArrayBuffer\nstatic base64ToArrayBuffer(base64){const binaryString=atob(base64);const bytes=new Uint8Array(binaryString.length);for(let i=0;i<binaryString.length;i++){bytes[i]=binaryString.charCodeAt(i);}return bytes.buffer;}// 合并多个 ArrayBuffer\nstatic concatenateArrayBuffers(buffers){const totalLength=buffers.reduce((acc,buffer)=>acc+buffer.byteLength,0);const result=new Uint8Array(totalLength);let offset=0;for(const buffer of buffers){result.set(new Uint8Array(buffer),offset);offset+=buffer.byteLength;}return result.buffer;}}// 减小分块大小，适应二维码限制\nFileTransferService.CHUNK_SIZE=200;","map":{"version":3,"names":["FileTransferService","parseHeader","data","header","JSON","parse","name","total_chunks","Error","e","fileToQRChunks","file","chunks","fileBuffer","arrayBuffer","uint8Array","Uint8Array","fileHash","calculateFileHash","Math","ceil","size","CHUNK_SIZE","hash","push","stringify","i","length","chunk","slice","chunkData","index","floor","arrayBufferToBase64","qrChunksToFile","fileName","headerChunk","find","parsed","expectedChunks","expectedHash","finalFileName","dataChunks","filter","undefined","sort","a","b","chunkA","chunkB","concat","fileChunks","map","base64ToArrayBuffer","combinedBuffer","concatenateArrayBuffers","actualHash","File","type","hashBuffer","crypto","subtle","digest","Array","from","toString","padStart","join","buffer","btoa","String","fromCharCode","apply","base64","binaryString","atob","bytes","charCodeAt","buffers","totalLength","reduce","acc","byteLength","result","offset","set"],"sources":["/Users/zhangrongwu/workspace/AI-Project/zhitrend-scan/file-transfer-web/src/services/fileTransferService.ts"],"sourcesContent":["import { createHash } from 'crypto';\n\ninterface FileHeader {\n  name: string;\n  total_chunks: number;  // 与 Flutter 版本保持一致\n  hash?: string;\n}\n\ninterface ChunkData {\n  index: number;\n  data: string;\n  total_chunks: number;  // 与 Flutter 版本保持一致\n  name?: string;\n}\n\nexport class FileTransferService {\n  // 减小分块大小，适应二维码限制\n  private static readonly CHUNK_SIZE = 200; // 从1000减小到200字节\n\n  // 解析文件头信息\n  static parseHeader(data: string): FileHeader {\n    try {\n      const header = JSON.parse(data) as FileHeader;\n      if (!header.name || !header.total_chunks) {\n        throw new Error('Invalid header format');\n      }\n      return header;\n    } catch (e) {\n      throw new Error('Invalid header data');\n    }\n  }\n\n  // 将文件分割成二维码数据块\n  static async fileToQRChunks(file: File): Promise<string[]> {\n    const chunks: string[] = [];\n    const fileBuffer = await file.arrayBuffer();\n    const uint8Array = new Uint8Array(fileBuffer);\n\n    // 计算文件哈希\n    const fileHash = await this.calculateFileHash(uint8Array);\n\n    // 文件头信息\n    const header: FileHeader = {\n      name: file.name,\n      total_chunks: Math.ceil(file.size / this.CHUNK_SIZE),\n      hash: fileHash,\n    };\n    chunks.push(JSON.stringify(header));\n\n    // 分块处理\n    for (let i = 0; i < uint8Array.length; i += this.CHUNK_SIZE) {\n      const chunk = uint8Array.slice(i, i + this.CHUNK_SIZE);\n      const chunkData: ChunkData = {\n        index: Math.floor(i / this.CHUNK_SIZE),\n        data: this.arrayBufferToBase64(chunk),\n        total_chunks: Math.ceil(uint8Array.length / this.CHUNK_SIZE),\n        name: file.name,\n      };\n      chunks.push(JSON.stringify(chunkData));\n    }\n\n    return chunks;\n  }\n\n  // 从二维码数据块重建文件\n  static async qrChunksToFile(chunks: string[], fileName?: string): Promise<File> {\n    if (chunks.length === 0) {\n      throw new Error('No chunks provided');\n    }\n\n    // 解析文件头\n    const headerChunk = chunks.find(chunk => {\n      const parsed = JSON.parse(chunk);\n      return parsed.total_chunks && parsed.name;\n    });\n\n    if (!headerChunk) {\n      throw new Error('No valid file header found');\n    }\n\n    const header = JSON.parse(headerChunk) as FileHeader;\n    const expectedChunks = header.total_chunks;\n    const expectedHash = header.hash;\n    const finalFileName = fileName || header.name;\n\n    // 解析数据块\n    const dataChunks = chunks.filter(chunk => {\n      const parsed = JSON.parse(chunk);\n      return parsed.index !== undefined && parsed.data;\n    }).sort((a, b) => {\n      const chunkA = JSON.parse(a) as ChunkData;\n      const chunkB = JSON.parse(b) as ChunkData;\n      return chunkA.index - chunkB.index;\n    });\n\n    if (dataChunks.length !== expectedChunks) {\n      throw new Error(`Incomplete chunks received. Expected ${expectedChunks}, got ${dataChunks.length}`);\n    }\n\n    // 重组文件数据\n    const fileChunks = dataChunks.map(chunk => {\n      const chunkData = JSON.parse(chunk) as ChunkData;\n      return this.base64ToArrayBuffer(chunkData.data);\n    });\n\n    // 合并文件数据\n    const combinedBuffer = this.concatenateArrayBuffers(fileChunks);\n    const uint8Array = new Uint8Array(combinedBuffer);\n\n    // 验证文件完整性\n    if (expectedHash) {\n      const actualHash = await this.calculateFileHash(uint8Array);\n      if (actualHash !== expectedHash) {\n        throw new Error('File integrity check failed');\n      }\n    }\n\n    // 创建文件\n    return new File([uint8Array], finalFileName, { type: 'application/octet-stream' });\n  }\n\n  // 计算文件哈希值（使用 Web Crypto API）\n  private static async calculateFileHash(data: Uint8Array): Promise<string> {\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    return Array.from(new Uint8Array(hashBuffer))\n      .map(b => b.toString(16).padStart(2, '0'))\n      .join('');\n  }\n\n  // ArrayBuffer 转 Base64\n  private static arrayBufferToBase64(buffer: Uint8Array): string {\n    return btoa(String.fromCharCode.apply(null, Array.from(buffer)));\n  }\n\n  // Base64 转 ArrayBuffer\n  private static base64ToArrayBuffer(base64: string): ArrayBuffer {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n  }\n\n  // 合并多个 ArrayBuffer\n  private static concatenateArrayBuffers(buffers: ArrayBuffer[]): ArrayBuffer {\n    const totalLength = buffers.reduce((acc, buffer) => acc + buffer.byteLength, 0);\n    const result = new Uint8Array(totalLength);\n    \n    let offset = 0;\n    for (const buffer of buffers) {\n      result.set(new Uint8Array(buffer), offset);\n      offset += buffer.byteLength;\n    }\n    \n    return result.buffer;\n  }\n}\n"],"mappings":"AAeA,MAAO,MAAM,CAAAA,mBAAoB,CAEW;AAE1C;AACA,MAAO,CAAAC,WAAWA,CAACC,IAAY,CAAc,CAC3C,GAAI,CACF,KAAM,CAAAC,MAAM,CAAGC,IAAI,CAACC,KAAK,CAACH,IAAI,CAAe,CAC7C,GAAI,CAACC,MAAM,CAACG,IAAI,EAAI,CAACH,MAAM,CAACI,YAAY,CAAE,CACxC,KAAM,IAAI,CAAAC,KAAK,CAAC,uBAAuB,CAAC,CAC1C,CACA,MAAO,CAAAL,MAAM,CACf,CAAE,MAAOM,CAAC,CAAE,CACV,KAAM,IAAI,CAAAD,KAAK,CAAC,qBAAqB,CAAC,CACxC,CACF,CAEA;AACA,YAAa,CAAAE,cAAcA,CAACC,IAAU,CAAqB,CACzD,KAAM,CAAAC,MAAgB,CAAG,EAAE,CAC3B,KAAM,CAAAC,UAAU,CAAG,KAAM,CAAAF,IAAI,CAACG,WAAW,CAAC,CAAC,CAC3C,KAAM,CAAAC,UAAU,CAAG,GAAI,CAAAC,UAAU,CAACH,UAAU,CAAC,CAE7C;AACA,KAAM,CAAAI,QAAQ,CAAG,KAAM,KAAI,CAACC,iBAAiB,CAACH,UAAU,CAAC,CAEzD;AACA,KAAM,CAAAZ,MAAkB,CAAG,CACzBG,IAAI,CAAEK,IAAI,CAACL,IAAI,CACfC,YAAY,CAAEY,IAAI,CAACC,IAAI,CAACT,IAAI,CAACU,IAAI,CAAG,IAAI,CAACC,UAAU,CAAC,CACpDC,IAAI,CAAEN,QACR,CAAC,CACDL,MAAM,CAACY,IAAI,CAACpB,IAAI,CAACqB,SAAS,CAACtB,MAAM,CAAC,CAAC,CAEnC;AACA,IAAK,GAAI,CAAAuB,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGX,UAAU,CAACY,MAAM,CAAED,CAAC,EAAI,IAAI,CAACJ,UAAU,CAAE,CAC3D,KAAM,CAAAM,KAAK,CAAGb,UAAU,CAACc,KAAK,CAACH,CAAC,CAAEA,CAAC,CAAG,IAAI,CAACJ,UAAU,CAAC,CACtD,KAAM,CAAAQ,SAAoB,CAAG,CAC3BC,KAAK,CAAEZ,IAAI,CAACa,KAAK,CAACN,CAAC,CAAG,IAAI,CAACJ,UAAU,CAAC,CACtCpB,IAAI,CAAE,IAAI,CAAC+B,mBAAmB,CAACL,KAAK,CAAC,CACrCrB,YAAY,CAAEY,IAAI,CAACC,IAAI,CAACL,UAAU,CAACY,MAAM,CAAG,IAAI,CAACL,UAAU,CAAC,CAC5DhB,IAAI,CAAEK,IAAI,CAACL,IACb,CAAC,CACDM,MAAM,CAACY,IAAI,CAACpB,IAAI,CAACqB,SAAS,CAACK,SAAS,CAAC,CAAC,CACxC,CAEA,MAAO,CAAAlB,MAAM,CACf,CAEA;AACA,YAAa,CAAAsB,cAAcA,CAACtB,MAAgB,CAAEuB,QAAiB,CAAiB,CAC9E,GAAIvB,MAAM,CAACe,MAAM,GAAK,CAAC,CAAE,CACvB,KAAM,IAAI,CAAAnB,KAAK,CAAC,oBAAoB,CAAC,CACvC,CAEA;AACA,KAAM,CAAA4B,WAAW,CAAGxB,MAAM,CAACyB,IAAI,CAACT,KAAK,EAAI,CACvC,KAAM,CAAAU,MAAM,CAAGlC,IAAI,CAACC,KAAK,CAACuB,KAAK,CAAC,CAChC,MAAO,CAAAU,MAAM,CAAC/B,YAAY,EAAI+B,MAAM,CAAChC,IAAI,CAC3C,CAAC,CAAC,CAEF,GAAI,CAAC8B,WAAW,CAAE,CAChB,KAAM,IAAI,CAAA5B,KAAK,CAAC,4BAA4B,CAAC,CAC/C,CAEA,KAAM,CAAAL,MAAM,CAAGC,IAAI,CAACC,KAAK,CAAC+B,WAAW,CAAe,CACpD,KAAM,CAAAG,cAAc,CAAGpC,MAAM,CAACI,YAAY,CAC1C,KAAM,CAAAiC,YAAY,CAAGrC,MAAM,CAACoB,IAAI,CAChC,KAAM,CAAAkB,aAAa,CAAGN,QAAQ,EAAIhC,MAAM,CAACG,IAAI,CAE7C;AACA,KAAM,CAAAoC,UAAU,CAAG9B,MAAM,CAAC+B,MAAM,CAACf,KAAK,EAAI,CACxC,KAAM,CAAAU,MAAM,CAAGlC,IAAI,CAACC,KAAK,CAACuB,KAAK,CAAC,CAChC,MAAO,CAAAU,MAAM,CAACP,KAAK,GAAKa,SAAS,EAAIN,MAAM,CAACpC,IAAI,CAClD,CAAC,CAAC,CAAC2C,IAAI,CAAC,CAACC,CAAC,CAAEC,CAAC,GAAK,CAChB,KAAM,CAAAC,MAAM,CAAG5C,IAAI,CAACC,KAAK,CAACyC,CAAC,CAAc,CACzC,KAAM,CAAAG,MAAM,CAAG7C,IAAI,CAACC,KAAK,CAAC0C,CAAC,CAAc,CACzC,MAAO,CAAAC,MAAM,CAACjB,KAAK,CAAGkB,MAAM,CAAClB,KAAK,CACpC,CAAC,CAAC,CAEF,GAAIW,UAAU,CAACf,MAAM,GAAKY,cAAc,CAAE,CACxC,KAAM,IAAI,CAAA/B,KAAK,yCAAA0C,MAAA,CAAyCX,cAAc,WAAAW,MAAA,CAASR,UAAU,CAACf,MAAM,CAAE,CAAC,CACrG,CAEA;AACA,KAAM,CAAAwB,UAAU,CAAGT,UAAU,CAACU,GAAG,CAACxB,KAAK,EAAI,CACzC,KAAM,CAAAE,SAAS,CAAG1B,IAAI,CAACC,KAAK,CAACuB,KAAK,CAAc,CAChD,MAAO,KAAI,CAACyB,mBAAmB,CAACvB,SAAS,CAAC5B,IAAI,CAAC,CACjD,CAAC,CAAC,CAEF;AACA,KAAM,CAAAoD,cAAc,CAAG,IAAI,CAACC,uBAAuB,CAACJ,UAAU,CAAC,CAC/D,KAAM,CAAApC,UAAU,CAAG,GAAI,CAAAC,UAAU,CAACsC,cAAc,CAAC,CAEjD;AACA,GAAId,YAAY,CAAE,CAChB,KAAM,CAAAgB,UAAU,CAAG,KAAM,KAAI,CAACtC,iBAAiB,CAACH,UAAU,CAAC,CAC3D,GAAIyC,UAAU,GAAKhB,YAAY,CAAE,CAC/B,KAAM,IAAI,CAAAhC,KAAK,CAAC,6BAA6B,CAAC,CAChD,CACF,CAEA;AACA,MAAO,IAAI,CAAAiD,IAAI,CAAC,CAAC1C,UAAU,CAAC,CAAE0B,aAAa,CAAE,CAAEiB,IAAI,CAAE,0BAA2B,CAAC,CAAC,CACpF,CAEA;AACA,YAAqB,CAAAxC,iBAAiBA,CAAChB,IAAgB,CAAmB,CACxE,KAAM,CAAAyD,UAAU,CAAG,KAAM,CAAAC,MAAM,CAACC,MAAM,CAACC,MAAM,CAAC,SAAS,CAAE5D,IAAI,CAAC,CAC9D,MAAO,CAAA6D,KAAK,CAACC,IAAI,CAAC,GAAI,CAAAhD,UAAU,CAAC2C,UAAU,CAAC,CAAC,CAC1CP,GAAG,CAACL,CAAC,EAAIA,CAAC,CAACkB,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,CAAC,CAAE,GAAG,CAAC,CAAC,CACzCC,IAAI,CAAC,EAAE,CAAC,CACb,CAEA;AACA,MAAe,CAAAlC,mBAAmBA,CAACmC,MAAkB,CAAU,CAC7D,MAAO,CAAAC,IAAI,CAACC,MAAM,CAACC,YAAY,CAACC,KAAK,CAAC,IAAI,CAAET,KAAK,CAACC,IAAI,CAACI,MAAM,CAAC,CAAC,CAAC,CAClE,CAEA;AACA,MAAe,CAAAf,mBAAmBA,CAACoB,MAAc,CAAe,CAC9D,KAAM,CAAAC,YAAY,CAAGC,IAAI,CAACF,MAAM,CAAC,CACjC,KAAM,CAAAG,KAAK,CAAG,GAAI,CAAA5D,UAAU,CAAC0D,YAAY,CAAC/C,MAAM,CAAC,CACjD,IAAK,GAAI,CAAAD,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGgD,YAAY,CAAC/C,MAAM,CAAED,CAAC,EAAE,CAAE,CAC5CkD,KAAK,CAAClD,CAAC,CAAC,CAAGgD,YAAY,CAACG,UAAU,CAACnD,CAAC,CAAC,CACvC,CACA,MAAO,CAAAkD,KAAK,CAACR,MAAM,CACrB,CAEA;AACA,MAAe,CAAAb,uBAAuBA,CAACuB,OAAsB,CAAe,CAC1E,KAAM,CAAAC,WAAW,CAAGD,OAAO,CAACE,MAAM,CAAC,CAACC,GAAG,CAAEb,MAAM,GAAKa,GAAG,CAAGb,MAAM,CAACc,UAAU,CAAE,CAAC,CAAC,CAC/E,KAAM,CAAAC,MAAM,CAAG,GAAI,CAAAnE,UAAU,CAAC+D,WAAW,CAAC,CAE1C,GAAI,CAAAK,MAAM,CAAG,CAAC,CACd,IAAK,KAAM,CAAAhB,MAAM,GAAI,CAAAU,OAAO,CAAE,CAC5BK,MAAM,CAACE,GAAG,CAAC,GAAI,CAAArE,UAAU,CAACoD,MAAM,CAAC,CAAEgB,MAAM,CAAC,CAC1CA,MAAM,EAAIhB,MAAM,CAACc,UAAU,CAC7B,CAEA,MAAO,CAAAC,MAAM,CAACf,MAAM,CACtB,CACF,CA7IE;AADWpE,mBAAmB,CAENsB,UAAU,CAAG,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}