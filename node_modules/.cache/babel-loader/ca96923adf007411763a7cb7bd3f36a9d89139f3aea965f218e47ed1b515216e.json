{"ast":null,"code":"export class FileTransferService {\n  // 从1000减小到200字节\n\n  // 解析文件头信息\n  static parseHeader(data) {\n    try {\n      const header = JSON.parse(data);\n      if (!header.name || !header.size || !header.hash || !header.chunks) {\n        throw new Error('Invalid header format');\n      }\n      return header;\n    } catch (e) {\n      throw new Error('Invalid header data');\n    }\n  }\n\n  // 将文件分割成二维码数据块\n  static async fileToQRChunks(file) {\n    const chunks = [];\n    const fileBuffer = await file.arrayBuffer();\n    const uint8Array = new Uint8Array(fileBuffer);\n\n    // 计算文件哈希\n    const fileHash = await this.calculateFileHash(uint8Array);\n\n    // 文件头信息\n    const header = {\n      name: file.name,\n      size: file.size,\n      hash: fileHash,\n      chunks: Math.ceil(file.size / this.CHUNK_SIZE)\n    };\n    chunks.push(JSON.stringify(header));\n\n    // 分块处理\n    for (let i = 0; i < uint8Array.length; i += this.CHUNK_SIZE) {\n      const chunk = uint8Array.slice(i, i + this.CHUNK_SIZE);\n      const chunkData = {\n        index: Math.floor(i / this.CHUNK_SIZE),\n        data: this.arrayBufferToBase64(chunk),\n        total: Math.ceil(uint8Array.length / this.CHUNK_SIZE)\n      };\n      chunks.push(JSON.stringify(chunkData));\n    }\n    return chunks;\n  }\n\n  // 从二维码数据块重建文件\n  static async qrChunksToFile(chunks, fileName) {\n    if (chunks.length === 0) {\n      throw new Error('No chunks provided');\n    }\n\n    // 解析文件头\n    const header = JSON.parse(chunks[0]);\n    const expectedChunks = header.chunks;\n    const expectedHash = header.hash;\n\n    // 解析数据块\n    const dataChunks = chunks.slice(1).sort((a, b) => {\n      const chunkA = JSON.parse(a);\n      const chunkB = JSON.parse(b);\n      return chunkA.index - chunkB.index;\n    });\n    if (dataChunks.length !== expectedChunks) {\n      throw new Error(`Incomplete chunks received. Expected ${expectedChunks}, got ${dataChunks.length}`);\n    }\n\n    // 重组文件数据\n    const fileChunks = dataChunks.map(chunk => {\n      const chunkData = JSON.parse(chunk);\n      return this.base64ToArrayBuffer(chunkData.data);\n    });\n\n    // 合并文件数据\n    const combinedBuffer = this.concatenateArrayBuffers(fileChunks);\n    const uint8Array = new Uint8Array(combinedBuffer);\n\n    // 验证文件完整性\n    const actualHash = await this.calculateFileHash(uint8Array);\n    if (actualHash !== expectedHash) {\n      throw new Error('File integrity check failed');\n    }\n\n    // 创建文件\n    return new File([uint8Array], fileName, {\n      type: 'application/octet-stream'\n    });\n  }\n\n  // 计算文件哈希值（使用 Web Crypto API）\n  static async calculateFileHash(data) {\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');\n  }\n\n  // ArrayBuffer 转 Base64\n  static arrayBufferToBase64(buffer) {\n    return btoa(String.fromCharCode.apply(null, Array.from(buffer)));\n  }\n\n  // Base64 转 ArrayBuffer\n  static base64ToArrayBuffer(base64) {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n  }\n\n  // 合并多个 ArrayBuffer\n  static concatenateArrayBuffers(buffers) {\n    const totalLength = buffers.reduce((acc, buffer) => acc + buffer.byteLength, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const buffer of buffers) {\n      result.set(new Uint8Array(buffer), offset);\n      offset += buffer.byteLength;\n    }\n    return result.buffer;\n  }\n}\n// 减小分块大小，适应二维码限制\nFileTransferService.CHUNK_SIZE = 200;","map":{"version":3,"names":["FileTransferService","parseHeader","data","header","JSON","parse","name","size","hash","chunks","Error","e","fileToQRChunks","file","fileBuffer","arrayBuffer","uint8Array","Uint8Array","fileHash","calculateFileHash","Math","ceil","CHUNK_SIZE","push","stringify","i","length","chunk","slice","chunkData","index","floor","arrayBufferToBase64","total","qrChunksToFile","fileName","expectedChunks","expectedHash","dataChunks","sort","a","b","chunkA","chunkB","fileChunks","map","base64ToArrayBuffer","combinedBuffer","concatenateArrayBuffers","actualHash","File","type","hashBuffer","crypto","subtle","digest","Array","from","toString","padStart","join","buffer","btoa","String","fromCharCode","apply","base64","binaryString","atob","bytes","charCodeAt","buffers","totalLength","reduce","acc","byteLength","result","offset","set"],"sources":["/Users/zhangrongwu/workspace/AI-Project/file-transfer-web/src/services/fileTransferService.ts"],"sourcesContent":["import { createHash } from 'crypto';\n\ninterface FileHeader {\n  name: string;\n  size: number;\n  hash: string;\n  chunks: number;\n}\n\ninterface ChunkData {\n  index: number;\n  data: string;\n  total: number;\n}\n\nexport class FileTransferService {\n  // 减小分块大小，适应二维码限制\n  private static readonly CHUNK_SIZE = 200; // 从1000减小到200字节\n\n  // 解析文件头信息\n  static parseHeader(data: string): FileHeader {\n    try {\n      const header = JSON.parse(data) as FileHeader;\n      if (!header.name || !header.size || !header.hash || !header.chunks) {\n        throw new Error('Invalid header format');\n      }\n      return header;\n    } catch (e) {\n      throw new Error('Invalid header data');\n    }\n  }\n\n  // 将文件分割成二维码数据块\n  static async fileToQRChunks(file: File): Promise<string[]> {\n    const chunks: string[] = [];\n    const fileBuffer = await file.arrayBuffer();\n    const uint8Array = new Uint8Array(fileBuffer);\n\n    // 计算文件哈希\n    const fileHash = await this.calculateFileHash(uint8Array);\n\n    // 文件头信息\n    const header: FileHeader = {\n      name: file.name,\n      size: file.size,\n      hash: fileHash,\n      chunks: Math.ceil(file.size / this.CHUNK_SIZE),\n    };\n    chunks.push(JSON.stringify(header));\n\n    // 分块处理\n    for (let i = 0; i < uint8Array.length; i += this.CHUNK_SIZE) {\n      const chunk = uint8Array.slice(i, i + this.CHUNK_SIZE);\n      const chunkData: ChunkData = {\n        index: Math.floor(i / this.CHUNK_SIZE),\n        data: this.arrayBufferToBase64(chunk),\n        total: Math.ceil(uint8Array.length / this.CHUNK_SIZE)\n      };\n      chunks.push(JSON.stringify(chunkData));\n    }\n\n    return chunks;\n  }\n\n  // 从二维码数据块重建文件\n  static async qrChunksToFile(chunks: string[], fileName: string): Promise<File> {\n    if (chunks.length === 0) {\n      throw new Error('No chunks provided');\n    }\n\n    // 解析文件头\n    const header = JSON.parse(chunks[0]) as FileHeader;\n    const expectedChunks = header.chunks;\n    const expectedHash = header.hash;\n\n    // 解析数据块\n    const dataChunks = chunks.slice(1).sort((a, b) => {\n      const chunkA = JSON.parse(a) as ChunkData;\n      const chunkB = JSON.parse(b) as ChunkData;\n      return chunkA.index - chunkB.index;\n    });\n\n    if (dataChunks.length !== expectedChunks) {\n      throw new Error(`Incomplete chunks received. Expected ${expectedChunks}, got ${dataChunks.length}`);\n    }\n\n    // 重组文件数据\n    const fileChunks = dataChunks.map(chunk => {\n      const chunkData = JSON.parse(chunk) as ChunkData;\n      return this.base64ToArrayBuffer(chunkData.data);\n    });\n\n    // 合并文件数据\n    const combinedBuffer = this.concatenateArrayBuffers(fileChunks);\n    const uint8Array = new Uint8Array(combinedBuffer);\n\n    // 验证文件完整性\n    const actualHash = await this.calculateFileHash(uint8Array);\n    if (actualHash !== expectedHash) {\n      throw new Error('File integrity check failed');\n    }\n\n    // 创建文件\n    return new File([uint8Array], fileName, { type: 'application/octet-stream' });\n  }\n\n  // 计算文件哈希值（使用 Web Crypto API）\n  private static async calculateFileHash(data: Uint8Array): Promise<string> {\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    return Array.from(new Uint8Array(hashBuffer))\n      .map(b => b.toString(16).padStart(2, '0'))\n      .join('');\n  }\n\n  // ArrayBuffer 转 Base64\n  private static arrayBufferToBase64(buffer: Uint8Array): string {\n    return btoa(String.fromCharCode.apply(null, Array.from(buffer)));\n  }\n\n  // Base64 转 ArrayBuffer\n  private static base64ToArrayBuffer(base64: string): ArrayBuffer {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n  }\n\n  // 合并多个 ArrayBuffer\n  private static concatenateArrayBuffers(buffers: ArrayBuffer[]): ArrayBuffer {\n    const totalLength = buffers.reduce((acc, buffer) => acc + buffer.byteLength, 0);\n    const result = new Uint8Array(totalLength);\n    \n    let offset = 0;\n    for (const buffer of buffers) {\n      result.set(new Uint8Array(buffer), offset);\n      offset += buffer.byteLength;\n    }\n    \n    return result.buffer;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}