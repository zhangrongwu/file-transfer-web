{"ast":null,"code":"import { createHash } from 'crypto';\nexport class FileTransferService {\n  // 每个二维码包含的字节数\n\n  // 解析文件头信息\n  static parseHeader(data) {\n    try {\n      const header = JSON.parse(data);\n      if (!header.name || !header.size || !header.hash || !header.chunks) {\n        throw new Error('Invalid header format');\n      }\n      return header;\n    } catch (e) {\n      throw new Error('Invalid header data');\n    }\n  }\n\n  // 将文件分割成二维码数据块\n  static async fileToQRChunks(file) {\n    const chunks = [];\n    const fileBuffer = await file.arrayBuffer();\n    const uint8Array = new Uint8Array(fileBuffer);\n\n    // 计算文件哈希\n    const fileHash = this.calculateFileHash(uint8Array);\n\n    // 文件头信息\n    const header = {\n      name: file.name,\n      size: file.size,\n      hash: fileHash,\n      chunks: Math.ceil(file.size / this.CHUNK_SIZE)\n    };\n    chunks.push(JSON.stringify(header));\n\n    // 分块处理\n    for (let i = 0; i < uint8Array.length; i += this.CHUNK_SIZE) {\n      const chunk = uint8Array.slice(i, i + this.CHUNK_SIZE);\n      const chunkData = {\n        index: Math.floor(i / this.CHUNK_SIZE),\n        data: this.arrayBufferToBase64(chunk)\n      };\n      chunks.push(JSON.stringify(chunkData));\n    }\n    return chunks;\n  }\n\n  // 从二维码数据块重建文件\n  static async qrChunksToFile(chunks, fileName) {\n    if (chunks.length === 0) {\n      throw new Error('No chunks provided');\n    }\n\n    // 解析文件头\n    const header = JSON.parse(chunks[0]);\n    const expectedChunks = header.chunks;\n    const expectedHash = header.hash;\n\n    // 解析数据块\n    const dataChunks = chunks.slice(1);\n    if (dataChunks.length !== expectedChunks) {\n      throw new Error('Incomplete chunks received');\n    }\n\n    // 重组文件数据\n    const fileChunks = dataChunks.map(chunk => {\n      const chunkData = JSON.parse(chunk);\n      return this.base64ToArrayBuffer(chunkData.data);\n    });\n\n    // 合并文件数据\n    const combinedBuffer = this.concatenateArrayBuffers(fileChunks);\n    const uint8Array = new Uint8Array(combinedBuffer);\n\n    // 验证文件完整性\n    const actualHash = this.calculateFileHash(uint8Array);\n    if (actualHash !== expectedHash) {\n      throw new Error('File integrity check failed');\n    }\n\n    // 创建文件\n    return new File([uint8Array], fileName, {\n      type: 'application/octet-stream'\n    });\n  }\n\n  // 计算文件哈希值\n  static calculateFileHash(data) {\n    const hashBuffer = createHash('sha256').update(data).digest('hex');\n    return hashBuffer;\n  }\n\n  // ArrayBuffer 转 Base64\n  static arrayBufferToBase64(buffer) {\n    return btoa(String.fromCharCode.apply(null, Array.from(buffer)));\n  }\n\n  // Base64 转 ArrayBuffer\n  static base64ToArrayBuffer(base64) {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n  }\n\n  // 合并多个 ArrayBuffer\n  static concatenateArrayBuffers(buffers) {\n    const totalLength = buffers.reduce((acc, buffer) => acc + buffer.byteLength, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const buffer of buffers) {\n      result.set(new Uint8Array(buffer), offset);\n      offset += buffer.byteLength;\n    }\n    return result.buffer;\n  }\n}\nFileTransferService.CHUNK_SIZE = 1000;","map":{"version":3,"names":["createHash","FileTransferService","parseHeader","data","header","JSON","parse","name","size","hash","chunks","Error","e","fileToQRChunks","file","fileBuffer","arrayBuffer","uint8Array","Uint8Array","fileHash","calculateFileHash","Math","ceil","CHUNK_SIZE","push","stringify","i","length","chunk","slice","chunkData","index","floor","arrayBufferToBase64","qrChunksToFile","fileName","expectedChunks","expectedHash","dataChunks","fileChunks","map","base64ToArrayBuffer","combinedBuffer","concatenateArrayBuffers","actualHash","File","type","hashBuffer","update","digest","buffer","btoa","String","fromCharCode","apply","Array","from","base64","binaryString","atob","bytes","charCodeAt","buffers","totalLength","reduce","acc","byteLength","result","offset","set"],"sources":["/Users/zhangrongwu/workspace/AI-Project/file-transfer-web/src/services/fileTransferService.ts"],"sourcesContent":["import { createHash } from 'crypto';\n\ninterface FileHeader {\n  name: string;\n  size: number;\n  hash: string;\n  chunks: number;\n}\n\ninterface ChunkData {\n  index: number;\n  data: string;\n}\n\nexport class FileTransferService {\n  private static readonly CHUNK_SIZE = 1000; // 每个二维码包含的字节数\n\n  // 解析文件头信息\n  static parseHeader(data: string): FileHeader {\n    try {\n      const header = JSON.parse(data) as FileHeader;\n      if (!header.name || !header.size || !header.hash || !header.chunks) {\n        throw new Error('Invalid header format');\n      }\n      return header;\n    } catch (e) {\n      throw new Error('Invalid header data');\n    }\n  }\n\n  // 将文件分割成二维码数据块\n  static async fileToQRChunks(file: File): Promise<string[]> {\n    const chunks: string[] = [];\n    const fileBuffer = await file.arrayBuffer();\n    const uint8Array = new Uint8Array(fileBuffer);\n\n    // 计算文件哈希\n    const fileHash = this.calculateFileHash(uint8Array);\n\n    // 文件头信息\n    const header: FileHeader = {\n      name: file.name,\n      size: file.size,\n      hash: fileHash,\n      chunks: Math.ceil(file.size / this.CHUNK_SIZE),\n    };\n    chunks.push(JSON.stringify(header));\n\n    // 分块处理\n    for (let i = 0; i < uint8Array.length; i += this.CHUNK_SIZE) {\n      const chunk = uint8Array.slice(i, i + this.CHUNK_SIZE);\n      const chunkData: ChunkData = {\n        index: Math.floor(i / this.CHUNK_SIZE),\n        data: this.arrayBufferToBase64(chunk),\n      };\n      chunks.push(JSON.stringify(chunkData));\n    }\n\n    return chunks;\n  }\n\n  // 从二维码数据块重建文件\n  static async qrChunksToFile(chunks: string[], fileName: string): Promise<File> {\n    if (chunks.length === 0) {\n      throw new Error('No chunks provided');\n    }\n\n    // 解析文件头\n    const header = JSON.parse(chunks[0]) as FileHeader;\n    const expectedChunks = header.chunks;\n    const expectedHash = header.hash;\n\n    // 解析数据块\n    const dataChunks = chunks.slice(1);\n    if (dataChunks.length !== expectedChunks) {\n      throw new Error('Incomplete chunks received');\n    }\n\n    // 重组文件数据\n    const fileChunks = dataChunks.map(chunk => {\n      const chunkData = JSON.parse(chunk) as ChunkData;\n      return this.base64ToArrayBuffer(chunkData.data);\n    });\n\n    // 合并文件数据\n    const combinedBuffer = this.concatenateArrayBuffers(fileChunks);\n    const uint8Array = new Uint8Array(combinedBuffer);\n\n    // 验证文件完整性\n    const actualHash = this.calculateFileHash(uint8Array);\n    if (actualHash !== expectedHash) {\n      throw new Error('File integrity check failed');\n    }\n\n    // 创建文件\n    return new File([uint8Array], fileName, { type: 'application/octet-stream' });\n  }\n\n  // 计算文件哈希值\n  private static calculateFileHash(data: Uint8Array): string {\n    const hashBuffer = createHash('sha256').update(data).digest('hex');\n    return hashBuffer;\n  }\n\n  // ArrayBuffer 转 Base64\n  private static arrayBufferToBase64(buffer: Uint8Array): string {\n    return btoa(String.fromCharCode.apply(null, Array.from(buffer)));\n  }\n\n  // Base64 转 ArrayBuffer\n  private static base64ToArrayBuffer(base64: string): ArrayBuffer {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n  }\n\n  // 合并多个 ArrayBuffer\n  private static concatenateArrayBuffers(buffers: ArrayBuffer[]): ArrayBuffer {\n    const totalLength = buffers.reduce((acc, buffer) => acc + buffer.byteLength, 0);\n    const result = new Uint8Array(totalLength);\n    \n    let offset = 0;\n    for (const buffer of buffers) {\n      result.set(new Uint8Array(buffer), offset);\n      offset += buffer.byteLength;\n    }\n    \n    return result.buffer;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}